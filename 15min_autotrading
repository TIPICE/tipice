# -*- coding: utf-8 -*-
"""
📌 업비트 자동매매 (지정가 추격 + 손절만 시장가)
   - 신호판단: 15분봉 + 5분봉 Slow Stochastic
     * 매수: 15m 골든크로스 AND 5m에서 K > D (동조)
     * 매도: 15m 데드크로스 AND 5m에서 K < D (동조)
   - 주문 집행:
     * 일반 매수/매도: '지정가 추격'(호가창 기반, 미체결 시 틱 단위 추격)
     * 손절(-1% 이하): '시장가'로 전량 즉시 청산
   - 안전장치: API 재시도/백오프, 레이트리밋 대기, 유니버스 TOP_N
"""

import os, time, random, argparse
import numpy as np
import pandas as pd
import pyupbit
from datetime import datetime, timedelta

# ===============================
# 0) 실행/로깅 옵션
# ===============================
DEBUG   = True
DRY_RUN = False   # ⚠️ 실거래 시 False 또는 --dry-run 0
def dlog(*a):
    if DEBUG: print("[DEBUG]", *a)
def log(tag, msg=""):
    print(f"[{tag}] {time.strftime('%Y-%m-%d %H:%M:%S')} | {msg}")

# ===============================
# 1) 사용자 설정
# ===============================
ACCESS = os.getenv("UPBIT_ACCESS", "YOUR_ACCESS_KEY")
SECRET = os.getenv("UPBIT_SECRET", "YOUR_SECRET_KEY")

CHECK_INTERVAL          = 60      # 자동 루프 주기(초)
SLEEP_API               = 0.35    # 각 API 콜 후 휴식(레이트리밋 여유)
MIN_ORDER_KRW           = 5000    # 업비트 최소 주문금액
PORTFOLIO_CUT_PCT       = -1.0    # 포트폴리오 손절 트리거(%)
TOP_N                   = 3       # 거래대금 상위 N개 유니버스
MIN_CANDLES_REQUIRED    = 20      # 각 타임프레임 최소 캔들(지표 안정화)
UNIVERSE_REFRESH_MIN    = 120     # 유니버스 재선정 주기(분)
SELL_MODE               = "full"  # or "equal_fraction" (동시신호시 분할매도)

# --- 지정가 추격(리프라이스) 파라미터 ---
OFFSET_TICKS_BUY  = 1    # 매수 시작: 최우선 매도호가 - 1틱 (스프레드 내 대기)
OFFSET_TICKS_SELL = 1    # 매도 시작: 최우선 매수호가 + 1틱 (스프레드 내 대기)
WAIT_PER_STEP     = 5    # 미체결 시 다음 추격 전 대기(초)
MAX_EXTRA_TICKS   = 3    # 시작 대비 최대 추가 추격 틱 수

# --- 재시도(백오프) ---
MAX_RETRIES = 3
BACKOFF_BASE = 1.0
BACKOFF_FACTOR = 2.0
JITTER = (0.0, 0.3)
LOOP_COOLDOWN_ON_FAILURE = 20

MANUAL_TICKERS = ["KRW-BTC", "KRW-ETH", "KRW-XRP"]

# 업비트 세션
upbit = pyupbit.Upbit(ACCESS, SECRET)

# ===============================
# 2) 공통: 재시도/백오프 래퍼
# ===============================
def api_call(fn, *args, **kwargs):
    last = None
    for i in range(1, MAX_RETRIES+1):
        try:
            r = fn(*args, **kwargs)
            time.sleep(SLEEP_API)
            return r
        except Exception as e:
            last = e
            msg = str(e)
            transient = any(k in msg.lower() for k in
                            ["요청 수 제한","429","timeout","timed out","temporarily","connection"])
            if i < MAX_RETRIES and transient:
                delay = BACKOFF_BASE * (BACKOFF_FACTOR ** (i-1)) + random.uniform(*JITTER)
                dlog(f"API retry {i}/{MAX_RETRIES} in {delay:.2f}s | {msg}")
                time.sleep(delay)
                continue
            break
    time.sleep(SLEEP_API)
    raise last if last else RuntimeError("API failed")

# ===============================
# 3) 시세/지표 유틸
# ===============================
def get_ohlcv_safe(ticker, interval, count):
    """결측/컬럼검증 포함 안전 호출"""
    try:
        df = api_call(pyupbit.get_ohlcv, ticker, interval=interval, count=count)
        if df is None or df.empty: return None
        need = {"open","high","low","close","volume","value"}
        if not need.issubset(df.columns): return None
        return df
    except Exception as e:
        dlog(f"[OHLCV 오류] {ticker} {interval} | {e}")
        return None

def last_closed_idx(df: pd.DataFrame) -> int:
    """마지막 '완성' 봉 인덱스(마지막 봉은 진행중일 수 있어 -2 사용)"""
    return -2 if len(df) >= 2 else -1

def stoch_slow(df: pd.DataFrame, n=14, k_slow=3, d_slow=3):
    """Slow %K, %D"""
    high_n = df["high"].rolling(n).max()
    low_n  = df["low"].rolling(n).min()
    denom  = (high_n - low_n).replace(0, np.nan)
    fast_k = 100 * (df["close"] - low_n) / denom
    fast_k = fast_k.fillna(method="bfill").fillna(method="ffill")
    slow_k = fast_k.rolling(k_slow).mean()
    slow_d = slow_k.rolling(d_slow).mean()
    return slow_k, slow_d

def cross_signal(df: pd.DataFrame):
    """단일 타임프레임 교차 신호 (완성봉 기준)"""
    if df is None or len(df) < MIN_CANDLES_REQUIRED: return None
    k, d = stoch_slow(df)
    i = last_closed_idx(df)
    try:
        k_now, d_now = float(k.iloc[i]), float(d.iloc[i])
        k_prev, d_prev = float(k.iloc[i-1]), float(d.iloc[i-1])
    except Exception:
        return None
    if any(map(lambda x: x is None or np.isnan(x), [k_now,d_now,k_prev,d_prev])): 
        return None
    buy  = (k_prev < d_prev) and (k_now > d_now)  # 골든
    sell = (k_prev > d_prev) and (k_now < d_now)  # 데드
    return {"buy": buy, "sell": sell, "bar_time": df.index[i], "k": k_now, "d": d_now}

def mtf_signal(df15: pd.DataFrame, df5: pd.DataFrame):
    """
    멀티타임프레임 신호:
      - 매수: 15m 골든크로스  AND  5m에서 K > D (동조)
      - 매도: 15m 데드크로스   AND  5m에서 K < D (동조)
    """
    s15 = cross_signal(df15)
    if s15 is None: return None
    if df5 is None or len(df5) < MIN_CANDLES_REQUIRED: return None
    k5, d5 = stoch_slow(df5); i5 = last_closed_idx(df5)
    try:
        k5n, d5n = float(k5.iloc[i5]), float(d5.iloc[i5])
    except Exception:
        return None
    buy  = s15["buy"]  and (k5n > d5n)
    sell = s15["sell"] and (k5n < d5n)
    return {"buy":buy, "sell":sell, "bar_time": s15["bar_time"], "k5":k5n, "d5":d5n}

# ===============================
# 4) 잔고/가격/유니버스
# ===============================
def get_balances():
    return api_call(upbit.get_balances)

def krw_balance(balances) -> float:
    for b in balances:
        if b["currency"] == "KRW":
            return float(b.get("balance", 0) or 0)
    return 0.0

def coin_qty(balances, ticker: str) -> float:
    sym = ticker.split("-")[1]
    for b in balances:
        if b["currency"] == sym:
            return float(b.get("balance", 0) or 0)
    return 0.0

def get_prices(tickers):
    try:
        p = api_call(pyupbit.get_current_price, tickers)
        if isinstance(p, (float,int)): return {tickers[0]: float(p)}
        return {k: float(v) for k,v in (p or {}).items()}
    except Exception as e:
        dlog("[현재가 오류]", e)
        return {}

def top_by_value(n=TOP_N):
    """거래대금 상위 n개 추출(상장 초기 제외)"""
    try:
        all_krw = api_call(pyupbit.get_tickers, fiat="KRW")
    except Exception as e:
        print("[티커목록 오류]", e); return MANUAL_TICKERS[:n]
    vals=[]
    for t in all_krw:
        df30 = get_ohlcv_safe(t, "minute30", 48)
        if df30 is None: continue
        df15 = get_ohlcv_safe(t, "minute15", MIN_CANDLES_REQUIRED)
        df5  = get_ohlcv_safe(t, "minute5",  MIN_CANDLES_REQUIRED)
        if df15 is None or len(df15)<MIN_CANDLES_REQUIRED: continue
        if df5  is None or len(df5) <MIN_CANDLES_REQUIRED: continue
        try: vals.append((t, float(df30["value"].sum())))
        except: pass
    vals.sort(key=lambda x:x[1], reverse=True)
    top = [t for t,_ in vals[:n]] or MANUAL_TICKERS[:n]
    log("UNIVERSE", f"{', '.join(top)} 선정")
    return top

# ===============================
# 5) 주문: 시장가(손절용) & 지정가 추격(일반용)
# ===============================
# ---- 손절/청산: 시장가 ----
def sell_market_all(balances, ticker, dry_run=True):
    qty = coin_qty(balances, ticker)
    if qty <= 0: return True
    if dry_run:
        log("DRY_RUN-SELL-MKT", f"{ticker} x {qty}"); return True
    api_call(upbit.sell_market_order, ticker, qty)
    log("SELL-MKT", f"{ticker} x {qty}")
    return True

def sell_all_holdings_market(balances, dry_run=True):
    tickers = [f"KRW-{b['currency']}" for b in balances
               if b["currency"]!="KRW" and float(b.get("balance",0) or 0)>0]
    if not tickers:
        print("[전량 매도] 보유 없음"); return
    for t in tickers: sell_market_all(balances, t, dry_run=dry_run)

# ---- 일반 집행: 지정가 추격 ----
def tick_size(p: float)->float:
    if p < 1: return 0.0001
    if p < 10: return 0.01
    if p < 100: return 0.1
    if p < 1000: return 1
    if p < 10000: return 5
    if p < 100000: return 10
    if p < 500000: return 50
    if p < 1000000: return 100
    return 500

def orderbook_price(ticker, side, offset_ticks=1):
    """호가창 기준 시작 가격(스프레드 내) 계산"""
    ob = api_call(pyupbit.get_orderbook, ticker)
    unit = ob["orderbook_units"][0]
    ask = float(unit["ask_price"]); bid = float(unit["bid_price"])
    ts  = tick_size((ask+bid)/2)
    if side=="buy":
        target = max(bid, min(ask, ask - offset_ticks*ts))
        price  = np.floor(target/ts+1e-9)*ts  # 매수는 내림
    else:
        target = max(bid, min(ask, bid + offset_ticks*ts))
        price  = np.ceil(target/ts-1e-9)*ts   # 매도는 올림
    price = max(bid, min(price, ask))
    return float(price)

def place_limit(side, ticker, price, qty, dry_run=True):
    p = int(round(price))
    if dry_run:
        log("DRY_RUN-LIMIT", f"{side.upper()} {ticker} @ {p} x {qty}")
        return {"uuid": f"dry-{time.time()}"}
    if side=="buy":  return api_call(upbit.buy_limit_order,  ticker, p, qty)
    else:            return api_call(upbit.sell_limit_order, ticker, p, qty)

def get_order(uuid, dry_run=True):
    if dry_run: return {"state":"wait","remaining_volume":"1","executed_volume":"0"}
    return api_call(upbit.get_order, uuid)

def cancel(uuid, dry_run=True):
    if dry_run: log("DRY_RUN-CANCEL", uuid); return True
    api_call(upbit.cancel_order, uuid); return True

def buy_limit_reprice(ticker, amount_krw, base=OFFSET_TICKS_BUY,
                      steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=True):
    """예산(amount_krw) 한도로 지정가 추격 매수"""
    if amount_krw < MIN_ORDER_KRW: return True
    budget = amount_krw * 0.999  # 수수료 여유
    for s in range(0, steps+1):
        px  = orderbook_price(ticker, "buy", base+s)
        qty = float(f"{max(0.0, budget/px):.8f}")
        if qty <= 0 or qty*px < MIN_ORDER_KRW: return True
        od = place_limit("buy", ticker, px, qty, dry_run=dry_run); uuid = od.get("uuid")
        log("ORDER-BUY-LMT", f"{ticker} step={s} @ {int(px)} x {qty} uuid={uuid}")
        time.sleep(wait)
        info = get_order(uuid, dry_run=dry_run)
        rem  = float(info.get("remaining_volume",0) or 0)
        exe  = float(info.get("executed_volume",0) or 0)
        if exe>0: budget = max(0.0, budget - exe*px)
        if rem<=0: log("FILLED","BUY LIMIT"); return True
        cancel(uuid, dry_run=dry_run)
    return False

def sell_limit_reprice_all(balances, ticker, base=OFFSET_TICKS_SELL,
                           steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=True):
    """보유수량 전량을 지정가 추격으로 매도"""
    remain = float(f"{coin_qty(balances,ticker):.8f}")
    if remain<=0: return True
    for s in range(0, steps+1):
        px = orderbook_price(ticker, "sell", base+s)
        od = place_limit("sell", ticker, px, remain, dry_run=dry_run); uuid=od.get("uuid")
        log("ORDER-SELL-LMT", f"{ticker} step={s} @ {int(px)} x {remain} uuid={uuid}")
        time.sleep(wait)
        info = get_order(uuid, dry_run=dry_run)
        rem  = float(info.get("remaining_volume",0) or 0)
        exe  = float(info.get("executed_volume",0) or 0)
        if exe>0: remain = float(f"{max(0.0, remain-exe):.8f}")
        if rem<=0 or remain<=0: log("FILLED","SELL LIMIT"); return True
        cancel(uuid, dry_run=dry_run)
    return False

# ===============================
# 6) 손익/상태
# ===============================
def portfolio_return(balances, prices):
    coins = [b for b in balances if b["currency"]!="KRW" and float(b.get("balance",0) or 0)>0]
    if not coins: return None
    cost=value=0.0
    for b in coins:
        t=f"KRW-{b['currency']}"; qty=float(b.get("balance",0) or 0)
        avg=float(b.get("avg_buy_price",0) or 0); pr=float(prices.get(t,0) or 0)
        cost += avg*qty; value += pr*qty
    if cost<=0: return None
    return (value-cost)/cost*100.0

def print_holdings(balances, prices):
    pr = portfolio_return(balances, prices)
    if pr is None: return
    sign = "+" if pr>=0 else ""
    log("HOLDINGS", f"수익률 {sign}{pr:.2f}%")

# ===============================
# 7) 원클릭 유틸(기본: 지정가 추격)
# ===============================
def buy_top_by_amount(amount_krw):
    top1 = top_by_value(1)[0]
    log("INFO", f"거래대금 1위: {top1}")
    buy_limit_reprice(top1, amount_krw, base=OFFSET_TICKS_BUY,
                      steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)

def sell_all_now_limit():
    bal = get_balances()
    ticks = [f"KRW-{b['currency']}"] * 0
    ticks = [f"KRW-{b['currency']}" for b in bal
             if b["currency"]!="KRW" and float(b.get("balance",0) or 0)>0]
    for t in ticks:
        sell_limit_reprice_all(bal, t, base=OFFSET_TICKS_SELL,
                               steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)

# ===============================
# 8) 자동매매 루프
#     - 일반: 지정가 추격
#     - 손절: 시장가 전량 청산
# ===============================
def run_loop():
    log("START", "loop start | normal=limit-reprice, cut=market")
    last_keys=set()
    uni = top_by_value(TOP_N)
    last_refresh = datetime.now()

    while True:
        failed=False
        try:
            # (1) 유니버스 재선정
            if (datetime.now()-last_refresh) >= timedelta(minutes=UNIVERSE_REFRESH_MIN):
                uni = top_by_value(TOP_N); last_refresh = datetime.now()

            # (2) 캐시 1회
            bal = get_balances()
            prices = get_prices(uni)
            log("HEARTBEAT", f"대상: {', '.join(uni)}")
            print_holdings(bal, prices)

            # (3) 손절: 수익률 ≤ -1% → '시장가' 전량 청산 (요청사항)
            pr = portfolio_return(bal, prices)
            if pr is not None and pr <= PORTFOLIO_CUT_PCT:
                log("PORTFOLIO-CUT", f"{pr:.2f}% ≤ {PORTFOLIO_CUT_PCT}% → 시장가 전량 청산")
                sell_all_holdings_market(bal, dry_run=DRY_RUN)

            # (4) 신호 계산 (15m+5m)
            buys, sells = [], []
            for t in uni:
                df15 = get_ohlcv_safe(t, "minute15", 80)
                df5  = get_ohlcv_safe(t, "minute5",  200)
                sig  = mtf_signal(df15, df5)
                if sig is None: 
                    dlog(f"{t} 신호없음"); 
                    continue
                key_buy  = (t, sig["bar_time"], "BUY")
                key_sell = (t, sig["bar_time"], "SELL")
                if sig["buy"]  and key_buy  not in last_keys:  buys.append((t, key_buy))
                if sig["sell"] and key_sell not in last_keys:  sells.append((t, key_sell))

            # (5) 매도 우선 (지정가 추격)
            if sells:
                n_sell = len(sells)
                for (t, key) in sells:
                    if SELL_MODE == "equal_fraction" and n_sell > 0:
                        # 간단 구현: 해당 코인 잔량만큼 임시 balances를 만들어 전량 매도 함수를 재사용
                        qty_total = coin_qty(bal, t)
                        part_qty  = round(qty_total * (1.0 / n_sell), 8)
                        if part_qty > 0:
                            fake_bal = []
                            sym = t.split("-")[1]
                            for b in bal:
                                if b["currency"] == sym:
                                    nb = dict(b); nb["balance"] = str(part_qty); fake_bal.append(nb)
                                else:
                                    fake_bal.append(b)
                            sell_limit_reprice_all(fake_bal, t, base=OFFSET_TICKS_SELL,
                                                   steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)
                    else:
                        sell_limit_reprice_all(bal, t, base=OFFSET_TICKS_SELL,
                                               steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)
                    last_keys.add(key)

            # (6) n등분 매수 (지정가 추격)
            if buys:
                n = len(buys)
                krw = krw_balance(bal)
                max_slots = int(krw // MIN_ORDER_KRW)
                if max_slots<=0:
                    print(f"[매수 스킵] 원화 부족({krw:.0f}원)")
                else:
                    m = min(n, max_slots)
                    each = krw / m
                    if each < MIN_ORDER_KRW:
                        m2 = int(krw // MIN_ORDER_KRW)
                        if m2<=0: 
                            print(f"[매수 스킵] 원화 부족({krw:.0f}원)")
                            m=0
                        else:
                            m = m2; each = krw / m
                    for i in range(m):
                        t, key = buys[i]
                        ok = buy_limit_reprice(t, each, base=OFFSET_TICKS_BUY,
                                               steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)
                        if ok: last_keys.add(key)

        except Exception as e:
            failed=True
            print("[오류]", e)

        time.sleep(LOOP_COOLDOWN_ON_FAILURE if failed else CHECK_INTERVAL)

# ===============================
# 9) CLI
# ===============================
def main():
    # 전역 먼저 선언(전역값을 수정하므로)
    global DRY_RUN, TOP_N, OFFSET_TICKS_BUY, OFFSET_TICKS_SELL, WAIT_PER_STEP, MAX_EXTRA_TICKS, upbit

    p = argparse.ArgumentParser()
    p.add_argument("--mode", choices=["loop","buytop","sellall"], default="loop",
                   help="loop=자동매매 / buytop=거래대금1위 지정가추격 매수 / sellall=보유 전량 지정가추격 매도")
    p.add_argument("--amount", type=int, default=5000, help="buytop 매수 금액")
    p.add_argument("--dry-run", type=int, default=0, help="1=모의, 0=실거래")
    p.add_argument("--access", type=str, default=None)
    p.add_argument("--secret", type=str, default=None)
    # 튜닝 파라미터(전역 기본을 덮어쓰기)
    p.add_argument("--top-n",       type=int, default=None)
    p.add_argument("--offset-buy",  type=int, default=None)
    p.add_argument("--offset-sell", type=int, default=None)
    p.add_argument("--wait-step",   type=int, default=None)
    p.add_argument("--max-ticks",   type=int, default=None)
    args = p.parse_args()

    DRY_RUN = bool(args.dry_run)
    if args.top_n       is not None: TOP_N             = args.top_n
    if args.offset_buy  is not None: OFFSET_TICKS_BUY  = args.offset_buy
    if args.offset_sell is not None: OFFSET_TICKS_SELL = args.offset_sell
    if args.wait_step   is not None: WAIT_PER_STEP     = args.wait_step
    if args.max_ticks   is not None: MAX_EXTRA_TICKS   = args.max_ticks

    acc = args.access or ACCESS
    sec = args.secret or SECRET
    upbit = pyupbit.Upbit(acc, sec)

    if args.mode=="loop":
        run_loop()
    elif args.mode=="buytop":
        buy_top_by_amount(args.amount)
    elif args.mode=="sellall":
        sell_all_now_limit()

if __name__ == "__main__":
    main()
