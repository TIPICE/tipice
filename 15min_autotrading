# -*- coding: utf-8 -*-
"""
ğŸ“Œ ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ (ì§€ì •ê°€ ì¶”ê²© + ì†ì ˆë§Œ ì‹œì¥ê°€)
   - ì‹ í˜¸íŒë‹¨: 15ë¶„ë´‰ + 5ë¶„ë´‰ Slow Stochastic
     * ë§¤ìˆ˜: 15m ê³¨ë“ í¬ë¡œìŠ¤ AND 5mì—ì„œ K > D (ë™ì¡°)
     * ë§¤ë„: 15m ë°ë“œí¬ë¡œìŠ¤ AND 5mì—ì„œ K < D (ë™ì¡°)
   - ì£¼ë¬¸ ì§‘í–‰:
     * ì¼ë°˜ ë§¤ìˆ˜/ë§¤ë„: 'ì§€ì •ê°€ ì¶”ê²©'(í˜¸ê°€ì°½ ê¸°ë°˜, ë¯¸ì²´ê²° ì‹œ í‹± ë‹¨ìœ„ ì¶”ê²©)
     * ì†ì ˆ(-1% ì´í•˜): 'ì‹œì¥ê°€'ë¡œ ì „ëŸ‰ ì¦‰ì‹œ ì²­ì‚°
   - ì•ˆì „ì¥ì¹˜: API ì¬ì‹œë„/ë°±ì˜¤í”„, ë ˆì´íŠ¸ë¦¬ë°‹ ëŒ€ê¸°, ìœ ë‹ˆë²„ìŠ¤ TOP_N
"""

import os, time, random, argparse
import numpy as np
import pandas as pd
import pyupbit
from datetime import datetime, timedelta

# ===============================
# 0) ì‹¤í–‰/ë¡œê¹… ì˜µì…˜
# ===============================
DEBUG   = True
DRY_RUN = False   # âš ï¸ ì‹¤ê±°ë˜ ì‹œ False ë˜ëŠ” --dry-run 0
def dlog(*a):
    if DEBUG: print("[DEBUG]", *a)
def log(tag, msg=""):
    print(f"[{tag}] {time.strftime('%Y-%m-%d %H:%M:%S')} | {msg}")

# ===============================
# 1) ì‚¬ìš©ì ì„¤ì •
# ===============================
ACCESS = os.getenv("UPBIT_ACCESS", "YOUR_ACCESS_KEY")
SECRET = os.getenv("UPBIT_SECRET", "YOUR_SECRET_KEY")

CHECK_INTERVAL          = 60      # ìë™ ë£¨í”„ ì£¼ê¸°(ì´ˆ)
SLEEP_API               = 0.35    # ê° API ì½œ í›„ íœ´ì‹(ë ˆì´íŠ¸ë¦¬ë°‹ ì—¬ìœ )
MIN_ORDER_KRW           = 5000    # ì—…ë¹„íŠ¸ ìµœì†Œ ì£¼ë¬¸ê¸ˆì•¡
PORTFOLIO_CUT_PCT       = -1.0    # í¬íŠ¸í´ë¦¬ì˜¤ ì†ì ˆ íŠ¸ë¦¬ê±°(%)
TOP_N                   = 3       # ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ Nê°œ ìœ ë‹ˆë²„ìŠ¤
MIN_CANDLES_REQUIRED    = 20      # ê° íƒ€ì„í”„ë ˆì„ ìµœì†Œ ìº”ë“¤(ì§€í‘œ ì•ˆì •í™”)
UNIVERSE_REFRESH_MIN    = 120     # ìœ ë‹ˆë²„ìŠ¤ ì¬ì„ ì • ì£¼ê¸°(ë¶„)
SELL_MODE               = "full"  # or "equal_fraction" (ë™ì‹œì‹ í˜¸ì‹œ ë¶„í• ë§¤ë„)

# --- ì§€ì •ê°€ ì¶”ê²©(ë¦¬í”„ë¼ì´ìŠ¤) íŒŒë¼ë¯¸í„° ---
OFFSET_TICKS_BUY  = 1    # ë§¤ìˆ˜ ì‹œì‘: ìµœìš°ì„  ë§¤ë„í˜¸ê°€ - 1í‹± (ìŠ¤í”„ë ˆë“œ ë‚´ ëŒ€ê¸°)
OFFSET_TICKS_SELL = 1    # ë§¤ë„ ì‹œì‘: ìµœìš°ì„  ë§¤ìˆ˜í˜¸ê°€ + 1í‹± (ìŠ¤í”„ë ˆë“œ ë‚´ ëŒ€ê¸°)
WAIT_PER_STEP     = 5    # ë¯¸ì²´ê²° ì‹œ ë‹¤ìŒ ì¶”ê²© ì „ ëŒ€ê¸°(ì´ˆ)
MAX_EXTRA_TICKS   = 3    # ì‹œì‘ ëŒ€ë¹„ ìµœëŒ€ ì¶”ê°€ ì¶”ê²© í‹± ìˆ˜

# --- ì¬ì‹œë„(ë°±ì˜¤í”„) ---
MAX_RETRIES = 3
BACKOFF_BASE = 1.0
BACKOFF_FACTOR = 2.0
JITTER = (0.0, 0.3)
LOOP_COOLDOWN_ON_FAILURE = 20

MANUAL_TICKERS = ["KRW-BTC", "KRW-ETH", "KRW-XRP"]

# ì—…ë¹„íŠ¸ ì„¸ì…˜
upbit = pyupbit.Upbit(ACCESS, SECRET)

# ===============================
# 2) ê³µí†µ: ì¬ì‹œë„/ë°±ì˜¤í”„ ë˜í¼
# ===============================
def api_call(fn, *args, **kwargs):
    last = None
    for i in range(1, MAX_RETRIES+1):
        try:
            r = fn(*args, **kwargs)
            time.sleep(SLEEP_API)
            return r
        except Exception as e:
            last = e
            msg = str(e)
            transient = any(k in msg.lower() for k in
                            ["ìš”ì²­ ìˆ˜ ì œí•œ","429","timeout","timed out","temporarily","connection"])
            if i < MAX_RETRIES and transient:
                delay = BACKOFF_BASE * (BACKOFF_FACTOR ** (i-1)) + random.uniform(*JITTER)
                dlog(f"API retry {i}/{MAX_RETRIES} in {delay:.2f}s | {msg}")
                time.sleep(delay)
                continue
            break
    time.sleep(SLEEP_API)
    raise last if last else RuntimeError("API failed")

# ===============================
# 3) ì‹œì„¸/ì§€í‘œ ìœ í‹¸
# ===============================
def get_ohlcv_safe(ticker, interval, count):
    """ê²°ì¸¡/ì»¬ëŸ¼ê²€ì¦ í¬í•¨ ì•ˆì „ í˜¸ì¶œ"""
    try:
        df = api_call(pyupbit.get_ohlcv, ticker, interval=interval, count=count)
        if df is None or df.empty: return None
        need = {"open","high","low","close","volume","value"}
        if not need.issubset(df.columns): return None
        return df
    except Exception as e:
        dlog(f"[OHLCV ì˜¤ë¥˜] {ticker} {interval} | {e}")
        return None

def last_closed_idx(df: pd.DataFrame) -> int:
    """ë§ˆì§€ë§‰ 'ì™„ì„±' ë´‰ ì¸ë±ìŠ¤(ë§ˆì§€ë§‰ ë´‰ì€ ì§„í–‰ì¤‘ì¼ ìˆ˜ ìˆì–´ -2 ì‚¬ìš©)"""
    return -2 if len(df) >= 2 else -1

def stoch_slow(df: pd.DataFrame, n=14, k_slow=3, d_slow=3):
    """Slow %K, %D"""
    high_n = df["high"].rolling(n).max()
    low_n  = df["low"].rolling(n).min()
    denom  = (high_n - low_n).replace(0, np.nan)
    fast_k = 100 * (df["close"] - low_n) / denom
    fast_k = fast_k.fillna(method="bfill").fillna(method="ffill")
    slow_k = fast_k.rolling(k_slow).mean()
    slow_d = slow_k.rolling(d_slow).mean()
    return slow_k, slow_d

def cross_signal(df: pd.DataFrame):
    """ë‹¨ì¼ íƒ€ì„í”„ë ˆì„ êµì°¨ ì‹ í˜¸ (ì™„ì„±ë´‰ ê¸°ì¤€)"""
    if df is None or len(df) < MIN_CANDLES_REQUIRED: return None
    k, d = stoch_slow(df)
    i = last_closed_idx(df)
    try:
        k_now, d_now = float(k.iloc[i]), float(d.iloc[i])
        k_prev, d_prev = float(k.iloc[i-1]), float(d.iloc[i-1])
    except Exception:
        return None
    if any(map(lambda x: x is None or np.isnan(x), [k_now,d_now,k_prev,d_prev])): 
        return None
    buy  = (k_prev < d_prev) and (k_now > d_now)  # ê³¨ë“ 
    sell = (k_prev > d_prev) and (k_now < d_now)  # ë°ë“œ
    return {"buy": buy, "sell": sell, "bar_time": df.index[i], "k": k_now, "d": d_now}

def mtf_signal(df15: pd.DataFrame, df5: pd.DataFrame):
    """
    ë©€í‹°íƒ€ì„í”„ë ˆì„ ì‹ í˜¸:
      - ë§¤ìˆ˜: 15m ê³¨ë“ í¬ë¡œìŠ¤  AND  5mì—ì„œ K > D (ë™ì¡°)
      - ë§¤ë„: 15m ë°ë“œí¬ë¡œìŠ¤   AND  5mì—ì„œ K < D (ë™ì¡°)
    """
    s15 = cross_signal(df15)
    if s15 is None: return None
    if df5 is None or len(df5) < MIN_CANDLES_REQUIRED: return None
    k5, d5 = stoch_slow(df5); i5 = last_closed_idx(df5)
    try:
        k5n, d5n = float(k5.iloc[i5]), float(d5.iloc[i5])
    except Exception:
        return None
    buy  = s15["buy"]  and (k5n > d5n)
    sell = s15["sell"] and (k5n < d5n)
    return {"buy":buy, "sell":sell, "bar_time": s15["bar_time"], "k5":k5n, "d5":d5n}

# ===============================
# 4) ì”ê³ /ê°€ê²©/ìœ ë‹ˆë²„ìŠ¤
# ===============================
def get_balances():
    return api_call(upbit.get_balances)

def krw_balance(balances) -> float:
    for b in balances:
        if b["currency"] == "KRW":
            return float(b.get("balance", 0) or 0)
    return 0.0

def coin_qty(balances, ticker: str) -> float:
    sym = ticker.split("-")[1]
    for b in balances:
        if b["currency"] == sym:
            return float(b.get("balance", 0) or 0)
    return 0.0

def get_prices(tickers):
    try:
        p = api_call(pyupbit.get_current_price, tickers)
        if isinstance(p, (float,int)): return {tickers[0]: float(p)}
        return {k: float(v) for k,v in (p or {}).items()}
    except Exception as e:
        dlog("[í˜„ì¬ê°€ ì˜¤ë¥˜]", e)
        return {}

def top_by_value(n=TOP_N):
    """ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ nê°œ ì¶”ì¶œ(ìƒì¥ ì´ˆê¸° ì œì™¸)"""
    try:
        all_krw = api_call(pyupbit.get_tickers, fiat="KRW")
    except Exception as e:
        print("[í‹°ì»¤ëª©ë¡ ì˜¤ë¥˜]", e); return MANUAL_TICKERS[:n]
    vals=[]
    for t in all_krw:
        df30 = get_ohlcv_safe(t, "minute30", 48)
        if df30 is None: continue
        df15 = get_ohlcv_safe(t, "minute15", MIN_CANDLES_REQUIRED)
        df5  = get_ohlcv_safe(t, "minute5",  MIN_CANDLES_REQUIRED)
        if df15 is None or len(df15)<MIN_CANDLES_REQUIRED: continue
        if df5  is None or len(df5) <MIN_CANDLES_REQUIRED: continue
        try: vals.append((t, float(df30["value"].sum())))
        except: pass
    vals.sort(key=lambda x:x[1], reverse=True)
    top = [t for t,_ in vals[:n]] or MANUAL_TICKERS[:n]
    log("UNIVERSE", f"{', '.join(top)} ì„ ì •")
    return top

# ===============================
# 5) ì£¼ë¬¸: ì‹œì¥ê°€(ì†ì ˆìš©) & ì§€ì •ê°€ ì¶”ê²©(ì¼ë°˜ìš©)
# ===============================
# ---- ì†ì ˆ/ì²­ì‚°: ì‹œì¥ê°€ ----
def sell_market_all(balances, ticker, dry_run=True):
    qty = coin_qty(balances, ticker)
    if qty <= 0: return True
    if dry_run:
        log("DRY_RUN-SELL-MKT", f"{ticker} x {qty}"); return True
    api_call(upbit.sell_market_order, ticker, qty)
    log("SELL-MKT", f"{ticker} x {qty}")
    return True

def sell_all_holdings_market(balances, dry_run=True):
    tickers = [f"KRW-{b['currency']}" for b in balances
               if b["currency"]!="KRW" and float(b.get("balance",0) or 0)>0]
    if not tickers:
        print("[ì „ëŸ‰ ë§¤ë„] ë³´ìœ  ì—†ìŒ"); return
    for t in tickers: sell_market_all(balances, t, dry_run=dry_run)

# ---- ì¼ë°˜ ì§‘í–‰: ì§€ì •ê°€ ì¶”ê²© ----
def tick_size(p: float)->float:
    if p < 1: return 0.0001
    if p < 10: return 0.01
    if p < 100: return 0.1
    if p < 1000: return 1
    if p < 10000: return 5
    if p < 100000: return 10
    if p < 500000: return 50
    if p < 1000000: return 100
    return 500

def orderbook_price(ticker, side, offset_ticks=1):
    """í˜¸ê°€ì°½ ê¸°ì¤€ ì‹œì‘ ê°€ê²©(ìŠ¤í”„ë ˆë“œ ë‚´) ê³„ì‚°"""
    ob = api_call(pyupbit.get_orderbook, ticker)
    unit = ob["orderbook_units"][0]
    ask = float(unit["ask_price"]); bid = float(unit["bid_price"])
    ts  = tick_size((ask+bid)/2)
    if side=="buy":
        target = max(bid, min(ask, ask - offset_ticks*ts))
        price  = np.floor(target/ts+1e-9)*ts  # ë§¤ìˆ˜ëŠ” ë‚´ë¦¼
    else:
        target = max(bid, min(ask, bid + offset_ticks*ts))
        price  = np.ceil(target/ts-1e-9)*ts   # ë§¤ë„ëŠ” ì˜¬ë¦¼
    price = max(bid, min(price, ask))
    return float(price)

def place_limit(side, ticker, price, qty, dry_run=True):
    p = int(round(price))
    if dry_run:
        log("DRY_RUN-LIMIT", f"{side.upper()} {ticker} @ {p} x {qty}")
        return {"uuid": f"dry-{time.time()}"}
    if side=="buy":  return api_call(upbit.buy_limit_order,  ticker, p, qty)
    else:            return api_call(upbit.sell_limit_order, ticker, p, qty)

def get_order(uuid, dry_run=True):
    if dry_run: return {"state":"wait","remaining_volume":"1","executed_volume":"0"}
    return api_call(upbit.get_order, uuid)

def cancel(uuid, dry_run=True):
    if dry_run: log("DRY_RUN-CANCEL", uuid); return True
    api_call(upbit.cancel_order, uuid); return True

def buy_limit_reprice(ticker, amount_krw, base=OFFSET_TICKS_BUY,
                      steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=True):
    """ì˜ˆì‚°(amount_krw) í•œë„ë¡œ ì§€ì •ê°€ ì¶”ê²© ë§¤ìˆ˜"""
    if amount_krw < MIN_ORDER_KRW: return True
    budget = amount_krw * 0.999  # ìˆ˜ìˆ˜ë£Œ ì—¬ìœ 
    for s in range(0, steps+1):
        px  = orderbook_price(ticker, "buy", base+s)
        qty = float(f"{max(0.0, budget/px):.8f}")
        if qty <= 0 or qty*px < MIN_ORDER_KRW: return True
        od = place_limit("buy", ticker, px, qty, dry_run=dry_run); uuid = od.get("uuid")
        log("ORDER-BUY-LMT", f"{ticker} step={s} @ {int(px)} x {qty} uuid={uuid}")
        time.sleep(wait)
        info = get_order(uuid, dry_run=dry_run)
        rem  = float(info.get("remaining_volume",0) or 0)
        exe  = float(info.get("executed_volume",0) or 0)
        if exe>0: budget = max(0.0, budget - exe*px)
        if rem<=0: log("FILLED","BUY LIMIT"); return True
        cancel(uuid, dry_run=dry_run)
    return False

def sell_limit_reprice_all(balances, ticker, base=OFFSET_TICKS_SELL,
                           steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=True):
    """ë³´ìœ ìˆ˜ëŸ‰ ì „ëŸ‰ì„ ì§€ì •ê°€ ì¶”ê²©ìœ¼ë¡œ ë§¤ë„"""
    remain = float(f"{coin_qty(balances,ticker):.8f}")
    if remain<=0: return True
    for s in range(0, steps+1):
        px = orderbook_price(ticker, "sell", base+s)
        od = place_limit("sell", ticker, px, remain, dry_run=dry_run); uuid=od.get("uuid")
        log("ORDER-SELL-LMT", f"{ticker} step={s} @ {int(px)} x {remain} uuid={uuid}")
        time.sleep(wait)
        info = get_order(uuid, dry_run=dry_run)
        rem  = float(info.get("remaining_volume",0) or 0)
        exe  = float(info.get("executed_volume",0) or 0)
        if exe>0: remain = float(f"{max(0.0, remain-exe):.8f}")
        if rem<=0 or remain<=0: log("FILLED","SELL LIMIT"); return True
        cancel(uuid, dry_run=dry_run)
    return False

# ===============================
# 6) ì†ìµ/ìƒíƒœ
# ===============================
def portfolio_return(balances, prices):
    coins = [b for b in balances if b["currency"]!="KRW" and float(b.get("balance",0) or 0)>0]
    if not coins: return None
    cost=value=0.0
    for b in coins:
        t=f"KRW-{b['currency']}"; qty=float(b.get("balance",0) or 0)
        avg=float(b.get("avg_buy_price",0) or 0); pr=float(prices.get(t,0) or 0)
        cost += avg*qty; value += pr*qty
    if cost<=0: return None
    return (value-cost)/cost*100.0

def print_holdings(balances, prices):
    pr = portfolio_return(balances, prices)
    if pr is None: return
    sign = "+" if pr>=0 else ""
    log("HOLDINGS", f"ìˆ˜ìµë¥  {sign}{pr:.2f}%")

# ===============================
# 7) ì›í´ë¦­ ìœ í‹¸(ê¸°ë³¸: ì§€ì •ê°€ ì¶”ê²©)
# ===============================
def buy_top_by_amount(amount_krw):
    top1 = top_by_value(1)[0]
    log("INFO", f"ê±°ë˜ëŒ€ê¸ˆ 1ìœ„: {top1}")
    buy_limit_reprice(top1, amount_krw, base=OFFSET_TICKS_BUY,
                      steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)

def sell_all_now_limit():
    bal = get_balances()
    ticks = [f"KRW-{b['currency']}"] * 0
    ticks = [f"KRW-{b['currency']}" for b in bal
             if b["currency"]!="KRW" and float(b.get("balance",0) or 0)>0]
    for t in ticks:
        sell_limit_reprice_all(bal, t, base=OFFSET_TICKS_SELL,
                               steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)

# ===============================
# 8) ìë™ë§¤ë§¤ ë£¨í”„
#     - ì¼ë°˜: ì§€ì •ê°€ ì¶”ê²©
#     - ì†ì ˆ: ì‹œì¥ê°€ ì „ëŸ‰ ì²­ì‚°
# ===============================
def run_loop():
    log("START", "loop start | normal=limit-reprice, cut=market")
    last_keys=set()
    uni = top_by_value(TOP_N)
    last_refresh = datetime.now()

    while True:
        failed=False
        try:
            # (1) ìœ ë‹ˆë²„ìŠ¤ ì¬ì„ ì •
            if (datetime.now()-last_refresh) >= timedelta(minutes=UNIVERSE_REFRESH_MIN):
                uni = top_by_value(TOP_N); last_refresh = datetime.now()

            # (2) ìºì‹œ 1íšŒ
            bal = get_balances()
            prices = get_prices(uni)
            log("HEARTBEAT", f"ëŒ€ìƒ: {', '.join(uni)}")
            print_holdings(bal, prices)

            # (3) ì†ì ˆ: ìˆ˜ìµë¥  â‰¤ -1% â†’ 'ì‹œì¥ê°€' ì „ëŸ‰ ì²­ì‚° (ìš”ì²­ì‚¬í•­)
            pr = portfolio_return(bal, prices)
            if pr is not None and pr <= PORTFOLIO_CUT_PCT:
                log("PORTFOLIO-CUT", f"{pr:.2f}% â‰¤ {PORTFOLIO_CUT_PCT}% â†’ ì‹œì¥ê°€ ì „ëŸ‰ ì²­ì‚°")
                sell_all_holdings_market(bal, dry_run=DRY_RUN)

            # (4) ì‹ í˜¸ ê³„ì‚° (15m+5m)
            buys, sells = [], []
            for t in uni:
                df15 = get_ohlcv_safe(t, "minute15", 80)
                df5  = get_ohlcv_safe(t, "minute5",  200)
                sig  = mtf_signal(df15, df5)
                if sig is None: 
                    dlog(f"{t} ì‹ í˜¸ì—†ìŒ"); 
                    continue
                key_buy  = (t, sig["bar_time"], "BUY")
                key_sell = (t, sig["bar_time"], "SELL")
                if sig["buy"]  and key_buy  not in last_keys:  buys.append((t, key_buy))
                if sig["sell"] and key_sell not in last_keys:  sells.append((t, key_sell))

            # (5) ë§¤ë„ ìš°ì„  (ì§€ì •ê°€ ì¶”ê²©)
            if sells:
                n_sell = len(sells)
                for (t, key) in sells:
                    if SELL_MODE == "equal_fraction" and n_sell > 0:
                        # ê°„ë‹¨ êµ¬í˜„: í•´ë‹¹ ì½”ì¸ ì”ëŸ‰ë§Œí¼ ì„ì‹œ balancesë¥¼ ë§Œë“¤ì–´ ì „ëŸ‰ ë§¤ë„ í•¨ìˆ˜ë¥¼ ì¬ì‚¬ìš©
                        qty_total = coin_qty(bal, t)
                        part_qty  = round(qty_total * (1.0 / n_sell), 8)
                        if part_qty > 0:
                            fake_bal = []
                            sym = t.split("-")[1]
                            for b in bal:
                                if b["currency"] == sym:
                                    nb = dict(b); nb["balance"] = str(part_qty); fake_bal.append(nb)
                                else:
                                    fake_bal.append(b)
                            sell_limit_reprice_all(fake_bal, t, base=OFFSET_TICKS_SELL,
                                                   steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)
                    else:
                        sell_limit_reprice_all(bal, t, base=OFFSET_TICKS_SELL,
                                               steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)
                    last_keys.add(key)

            # (6) në“±ë¶„ ë§¤ìˆ˜ (ì§€ì •ê°€ ì¶”ê²©)
            if buys:
                n = len(buys)
                krw = krw_balance(bal)
                max_slots = int(krw // MIN_ORDER_KRW)
                if max_slots<=0:
                    print(f"[ë§¤ìˆ˜ ìŠ¤í‚µ] ì›í™” ë¶€ì¡±({krw:.0f}ì›)")
                else:
                    m = min(n, max_slots)
                    each = krw / m
                    if each < MIN_ORDER_KRW:
                        m2 = int(krw // MIN_ORDER_KRW)
                        if m2<=0: 
                            print(f"[ë§¤ìˆ˜ ìŠ¤í‚µ] ì›í™” ë¶€ì¡±({krw:.0f}ì›)")
                            m=0
                        else:
                            m = m2; each = krw / m
                    for i in range(m):
                        t, key = buys[i]
                        ok = buy_limit_reprice(t, each, base=OFFSET_TICKS_BUY,
                                               steps=MAX_EXTRA_TICKS, wait=WAIT_PER_STEP, dry_run=DRY_RUN)
                        if ok: last_keys.add(key)

        except Exception as e:
            failed=True
            print("[ì˜¤ë¥˜]", e)

        time.sleep(LOOP_COOLDOWN_ON_FAILURE if failed else CHECK_INTERVAL)

# ===============================
# 9) CLI
# ===============================
def main():
    # ì „ì—­ ë¨¼ì € ì„ ì–¸(ì „ì—­ê°’ì„ ìˆ˜ì •í•˜ë¯€ë¡œ)
    global DRY_RUN, TOP_N, OFFSET_TICKS_BUY, OFFSET_TICKS_SELL, WAIT_PER_STEP, MAX_EXTRA_TICKS, upbit

    p = argparse.ArgumentParser()
    p.add_argument("--mode", choices=["loop","buytop","sellall"], default="loop",
                   help="loop=ìë™ë§¤ë§¤ / buytop=ê±°ë˜ëŒ€ê¸ˆ1ìœ„ ì§€ì •ê°€ì¶”ê²© ë§¤ìˆ˜ / sellall=ë³´ìœ  ì „ëŸ‰ ì§€ì •ê°€ì¶”ê²© ë§¤ë„")
    p.add_argument("--amount", type=int, default=5000, help="buytop ë§¤ìˆ˜ ê¸ˆì•¡")
    p.add_argument("--dry-run", type=int, default=0, help="1=ëª¨ì˜, 0=ì‹¤ê±°ë˜")
    p.add_argument("--access", type=str, default=None)
    p.add_argument("--secret", type=str, default=None)
    # íŠœë‹ íŒŒë¼ë¯¸í„°(ì „ì—­ ê¸°ë³¸ì„ ë®ì–´ì“°ê¸°)
    p.add_argument("--top-n",       type=int, default=None)
    p.add_argument("--offset-buy",  type=int, default=None)
    p.add_argument("--offset-sell", type=int, default=None)
    p.add_argument("--wait-step",   type=int, default=None)
    p.add_argument("--max-ticks",   type=int, default=None)
    args = p.parse_args()

    DRY_RUN = bool(args.dry_run)
    if args.top_n       is not None: TOP_N             = args.top_n
    if args.offset_buy  is not None: OFFSET_TICKS_BUY  = args.offset_buy
    if args.offset_sell is not None: OFFSET_TICKS_SELL = args.offset_sell
    if args.wait_step   is not None: WAIT_PER_STEP     = args.wait_step
    if args.max_ticks   is not None: MAX_EXTRA_TICKS   = args.max_ticks

    acc = args.access or ACCESS
    sec = args.secret or SECRET
    upbit = pyupbit.Upbit(acc, sec)

    if args.mode=="loop":
        run_loop()
    elif args.mode=="buytop":
        buy_top_by_amount(args.amount)
    elif args.mode=="sellall":
        sell_all_now_limit()

if __name__ == "__main__":
    main()
