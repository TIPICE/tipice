# -*- coding: utf-8 -*-
"""
ğŸ“Œ ì¼ë´‰ + 4ì‹œê°„ë´‰ ì¡°ê±´ì´ ë™ì‹œì— ë§Œì¡±í•  ë•Œë§Œ ë§¤ë§¤í•˜ëŠ” í”„ë¡œê·¸ë¨
   + ì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ ìˆ˜ìµë¥ ì´ -2% ì´í•˜ì¼ ë•Œ ì „ëŸ‰ ì†ì ˆ
   + 5ì¢…ëª©ì„ ì„ ì •í•˜ì—¬ ë³´ìœ  ì›í™”ì˜ 20%ì”© ë¶„í•  ë§¤ìˆ˜

[ì „ëµ íë¦„]
1. ë§¤ 5ë¶„ë§ˆë‹¤ ëª¨ë“  ì¢…ëª©ì˜ ë§¤ìˆ˜/ë§¤ë„ ì‹ í˜¸ë¥¼ í™•ì¸
2. ë§¤ìˆ˜ ì‹ í˜¸ê°€ ëœ¨ë©´ ë³´ìœ  í˜„ê¸ˆì˜ 20%ì”© 5ì¢…ëª© ë§¤ìˆ˜
3. ë§¤ë„ ì‹ í˜¸ê°€ ëœ¨ë©´ í•´ë‹¹ ì¢…ëª© ì „ëŸ‰ ë§¤ë„
4. ì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ê°€ -2% ì†ì‹¤ì´ë©´ ëª¨ë“  ì¢…ëª© ì „ëŸ‰ ë§¤ë„
"""
import time
import numpy as np
import pandas as pd
import pyupbit
from datetime import datetime

# ===============================
# 1. ì‚¬ìš©ì ì„¤ì • (API í‚¤ì™€ ê¸°ë³¸ ì„¤ì •)
# ===============================
ACCESS = "b2VTQoW5F7ftGITzLSLPRoQoJuxx3rPCxyhvN6Z6"  # ì—…ë¹„íŠ¸ Open APIì—ì„œ ë°œê¸‰ë°›ì€ Access Key
SECRET = "5Sa4zfoxx9JoXx87rbD6j6cmUmBMYdTRSCxQoZlo"  # ì—…ë¹„íŠ¸ Open APIì—ì„œ ë°œê¸‰ë°›ì€ Secret Key
# â¬‡ï¸ ìë™ ì„ ì •/ìˆ˜ë™ ê³ ì • ì¤‘ ì„ íƒ
USE_AUTO_TOP5 = True
MANUAL_TICKERS = ["KRW-BTC", "KRW-ETH", "KRW-XRP", "KRW-SOL", "KRW-ADA"]  # USE_AUTO_TOP5=Falseì¼ ë•Œ ì‚¬ìš©

CHECK_INTERVAL = 300    # ì „ëµ ë°˜ë³µ ì£¼ê¸° (ì´ˆ) â†’ 300ì´ˆ = 5ë¶„ë§ˆë‹¤ ì‹¤í–‰
SLEEP_API = 0.12        # API í˜¸ì¶œ ê°„ ëŒ€ê¸° ì‹œê°„ (ì—…ë¹„íŠ¸ ì œí•œ íšŒí”¼ìš©)
MIN_ORDER_KRW = 5000    # ì—…ë¹„íŠ¸ ìµœì†Œ ì£¼ë¬¸ ê¸ˆì•¡ (5ì²œì›)

# í¬íŠ¸í´ë¦¬ì˜¤ ì†ì ˆ í•œë„
PORTFOLIO_CUT_PCT = -2.0  # -2% ì´í•˜ì´ë©´ ì „ëŸ‰ ë§¤ë„

upbit = pyupbit.Upbit(ACCESS, SECRET)
# ===============================
# 2. OHLCV(ì‹œê°€,ê³ ê°€,ì €ê°€,ì¢…ê°€,ê±°ë˜ëŸ‰) ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
# ===============================
def get_ohlcv(ticker: str, interval: str, count: int = 120) -> pd.DataFrame:
    """
    ì—…ë¹„íŠ¸ì—ì„œ ìº”ë“¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    ticker: ì¢…ëª©ëª… (ì˜ˆ: "KRW-BTC")
    interval: "day"(ì¼ë´‰), "minute240"(4ì‹œê°„ë´‰)
    count: ê°€ì ¸ì˜¬ ìº”ë“¤ ê°œìˆ˜
    """
    df = pyupbit.get_ohlcv(ticker, interval=interval, count=count)
    if df is None or df.empty:
        raise RuntimeError(f"{ticker} {interval} ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨")
    return df

def latest_completed_index(df: pd.DataFrame) -> int:
    """
    ë§ˆì§€ë§‰ìœ¼ë¡œ ì™„ì„±ëœ ë´‰ì˜ ì¸ë±ìŠ¤ ë°˜í™˜
    - dfì˜ ë§ˆì§€ë§‰ í–‰ì€ í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ìº”ë“¤ì´ë¯€ë¡œ, ê·¸ ì „(-2)ì„ ì‚¬ìš©
    """
    return -2 if len(df) >= 2 else -1

# ===============================
# 3. ë³´ì¡°ì§€í‘œ ê³„ì‚° (Stochastic Slow, ì´ê²©ë„)
# ===============================
def calc_stochastic_slow(df: pd.DataFrame, n: int = 14, k_slow: int = 3, d_slow: int = 3):
    """
    Slow Stochastic ê³„ì‚°
    Fast %K = (ì¢…ê°€ - Nê¸°ê°„ ìµœì €ê°€) / (Nê¸°ê°„ ìµœê³ ê°€ - Nê¸°ê°„ ìµœì €ê°€) * 100
    Slow %K = Fast %Kì˜ k_slowê¸°ê°„ ì´ë™í‰ê· 
    Slow %D = Slow %Kì˜ d_slowê¸°ê°„ ì´ë™í‰ê· 
    """
    high_n = df["high"].rolling(n).max()  # Nì¼ ì¤‘ ìµœê³ ê°€
    low_n = df["low"].rolling(n).min()    # Nì¼ ì¤‘ ìµœì €ê°€
    denom = (high_n - low_n)              # ë¶„ëª¨ (ê³ ê°€-ì €ê°€)

    # ë¶„ëª¨ê°€ 0ì¸ ê²½ìš° NaN ë°©ì§€
    fast_k = 100 * (df["close"] - low_n) / denom.replace(0, np.nan)
    fast_k = fast_k.fillna(method="bfill").fillna(method="ffill")  # NaN ì±„ìš°ê¸°

    slow_k = fast_k.rolling(k_slow).mean()  # Slow %K
    slow_d = slow_k.rolling(d_slow).mean()  # Slow %D
    return slow_k, slow_d

def calc_disparity_current_price(df: pd.DataFrame, current_price: float, ma_period: int = 20, idx: int = -2):
    """
    í˜„ì¬ê°€ ê¸°ì¤€ ì´ê²©ë„ ê³„ì‚°
    = (í˜„ì¬ê°€ / ì´ë™í‰ê· ì„ ) * 100
    """
    ma_series = df["close"].rolling(ma_period).mean()
    ma_val = float(ma_series.iloc[idx])
    if ma_val == 0 or np.isnan(ma_val):
        return None
    return (current_price / ma_val) * 100

# ===============================
# 4. í˜„ì¬ê°€ ë° ì”ê³  ì¡°íšŒ
# ===============================
def get_current_price(ticker: str) -> float:
    """í˜„ì¬ê°€ ì¡°íšŒ"""
    return pyupbit.get_current_price(ticker)

def get_krw_balance() -> float:
    """ë³´ìœ  ì›í™” ì¡°íšŒ"""
    balances = upbit.get_balances()
    for b in balances:
        if b["currency"] == "KRW":
            return float(b.get("balance", 0) or 0)
    return 0.0

def get_coin_balance(ticker: str) -> float:
    """ë³´ìœ  ì½”ì¸ ìˆ˜ëŸ‰ ì¡°íšŒ"""
    symbol = ticker.split("-")[1]
    balances = upbit.get_balances()
    for b in balances:
        if b["currency"] == symbol:
            return float(b.get("balance", 0) or 0)
    return 0.0

# ===============================
# 5. ë§¤ìˆ˜ / ë§¤ë„ í•¨ìˆ˜
# ===============================
def buy_limit_by_krw(ticker: str, use_krw: float, ref_price: float):
    if use_krw < MIN_ORDER_KRW:
        print(f"[ë§¤ìˆ˜ ê±´ë„ˆëœ€] ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ë¯¸ë§Œ({use_krw:.0f}) - {ticker}")
        return
    p = int(round(ref_price))
    qty = round(use_krw / p, 8)
    try:
        upbit.buy_limit_order(ticker, p, qty)
        print(f"[ë§¤ìˆ˜ ì£¼ë¬¸] {ticker} {p}ì› x {qty}ê°œ (ì•½ {use_krw:.0f} KRW)")
    except Exception as e:
        print(f"[ë§¤ìˆ˜ ì‹¤íŒ¨] {ticker} - {e}")

def sell_limit_all_coin(ticker: str, price: float):
    """
    ë³´ìœ  ì½”ì¸ ì „ëŸ‰ ì§€ì •ê°€ ë§¤ë„
    """
    qty = get_coin_balance(ticker)
    if qty <= 0:
        print("[ë§¤ë„ ë¶ˆê°€] ë³´ìœ  ìˆ˜ëŸ‰ ì—†ìŒ")
        return
    p = int(round(price))
    try:
        upbit.sell_limit_order(ticker, p, qty)
        print(f"[ë§¤ë„ ì£¼ë¬¸] {ticker} {p}ì›, {qty}ê°œ")
    except Exception as e:
        print(f"[ë§¤ë„ ì‹¤íŒ¨] {e}")

def sell_limit_all_holdings_at_market_price_snapshot():
    """
    ë³´ìœ  ì¤‘ì¸ ëª¨ë“  ì½”ì¸ì„ 'í˜„ì¬ê°€'ë¡œ ì§€ì •ê°€ ì „ëŸ‰ ë§¤ë„ (ìŠ¤ëƒ…ìƒ· ê¸°ë°˜)
    """
    balances = upbit.get_balances()
    tickers = [f"KRW-{b['currency']}" for b in balances
               if b["currency"] != "KRW" and float(b.get("balance", 0) or 0) > 0]
    if not tickers:
        print("[ì „ëŸ‰ ë§¤ë„] ë³´ìœ  ì½”ì¸ ì—†ìŒ")
        return
    prices = pyupbit.get_current_price(tickers)
    # ë‹¨ì¼ í‹°ì»¤ì¼ ë•Œ pricesê°€ floatë¡œ ë°˜í™˜ë  ìˆ˜ ìˆì–´ ë³´ì •
    if isinstance(prices, float) or isinstance(prices, int):
        prices = {tickers[0]: float(prices)}
    for t in tickers:
        pr = float(prices.get(t, 0) or 0)
        if pr > 0:
            sell_limit_all_coin(t, pr)
            time.sleep(SLEEP_API)

# ===============================
# 6. ì¡°ê±´ ì²´í¬ í•¨ìˆ˜
# ===============================
def get_signal_for_timeframe(df: pd.DataFrame, current_price: float):
    """
    ì£¼ì–´ì§„ ë°ì´í„°í”„ë ˆì„(ì¼ë´‰/4ì‹œê°„ë´‰)ì—ì„œ ë§¤ìˆ˜/ë§¤ë„ ì¡°ê±´ ì²´í¬
    + ì´ê²©ë„ ì¡°ê±´ì€ ë§¤ìˆ˜/ë§¤ë„ì—ì„œ ì œì™¸í•˜ê³  ë³„ë„ ì•Œë¦¼
    """
    # âœ… Stochastic Slow ê³„ì‚°
    slow_k, slow_d = calc_stochastic_slow(df)

    # ë§ˆì§€ë§‰ ì™„ë£Œëœ ë´‰ì˜ ì¸ë±ìŠ¤
    idx = latest_completed_index(df)

    # í˜„ì¬ ë´‰ì˜ %K, %D
    k_now = float(slow_k.iloc[idx])
    d_now = float(slow_d.iloc[idx])

    # ì´ì „ ë´‰ì˜ %K, %D
    k_prev = float(slow_k.iloc[idx-1]) if len(df) >= 3 else np.nan
    d_prev = float(slow_d.iloc[idx-1]) if len(df) >= 3 else np.nan

    # í˜„ì¬ê°€ ê¸°ë°˜ ì´ê²©ë„ ê³„ì‚° (20ê¸°ê°„)
    disp = calc_disparity_current_price(df, current_price, 20, idx)

    # ğŸ“Œ ë§¤ìˆ˜ ì¡°ê±´: ê³¨ë“ í¬ë¡œìŠ¤ + %Kê°€ 20ì„  ëŒíŒŒ
    buy_cond = (
        (k_prev < d_prev) and      # ì´ì „ ë´‰ì—ì„œ %K < %D
        (k_now > d_now) and        # í˜„ì¬ %K > %D
        (k_prev <= 20) and         # ì´ì „ ë´‰ %K â‰¤ 20
        (k_now > 5)               # í˜„ì¬ ë´‰ %K > 10
    )

    # ğŸ“Œ ë§¤ë„ ì¡°ê±´: %Kì™€ %Dê°€ ëª¨ë‘ 80 ì´ìƒì´ê³ , %Kê°€ %Dë¥¼ í•˜í–¥ ëŒíŒŒ
    sell_cond = (
        (k_prev >= 80) and 
        (k_prev > d_prev) and
        (k_now < d_now)
    )

    # ğŸ“¢ ì´ê²©ë„ ì•Œë¦¼
    disparity_alert = (disp is not None and disp <= 80)

    return {
        "buy": buy_cond,
        "sell": sell_cond,
        "disp_alert": disparity_alert,  # ì´ê²©ë„ ì¡°ê±´ ì•Œë¦¼
        "disp_value": disp,             # í˜„ì¬ ì´ê²©ë„ ê°’
        "bar_time": df.index[idx]
    }
# ===============================
# 7) ì¢…ëª© ì„ ì •
# ===============================
def get_top_tickers_by_value(n=5):
    """
    ìµœê·¼ 24ì‹œê°„ ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ ì¢…ëª© ë°˜í™˜
    """
    all_krw = pyupbit.get_tickers(fiat="KRW")
    vals = []
    for t in all_krw:
        try:
            df = pyupbit.get_ohlcv(t, interval="minute30", count=48)  # 30ë¶„ë´‰ Ã— 48ê°œ = ì•½ 24ì‹œê°„
            v = float(df["value"].sum())
            vals.append((t, v))
            time.sleep(0.05)
        except:
            continue
    vals.sort(key=lambda x: x[1], reverse=True)
    return [t for t, _ in vals[:n]]

def choose_universe():
    """ì¢…ëª© ì„ íƒ (ìë™ or ìˆ˜ë™)"""
    if USE_AUTO_TOP5:
        u = get_top_tickers_by_value(5)
        print("[ìë™ ì„ ì • ì¢…ëª©]", u)
        return u
    return MANUAL_TICKERS[:5]

# ===============================
# 8) í¬íŠ¸í´ë¦¬ì˜¤ ì „ì²´ ì†ìµë¥  ê³„ì‚°
# ===============================
def get_portfolio_return_pct():
    """
    ì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ì˜ ì†ìµë¥ (%) ê³„ì‚°
    """
    balances = upbit.get_balances()
    coins = [b for b in balances if b["currency"] != "KRW" and float(b.get("balance", 0) or 0) > 0]
    if not coins:
        return None

    tickers = [f"KRW-{b['currency']}" for b in coins]
    prices = pyupbit.get_current_price(tickers)
    if isinstance(prices, float):
        prices = {tickers[0]: prices}

    total_cost = 0
    total_value = 0
    for b in coins:
        ticker = f"KRW-{b['currency']}"
        qty = float(b["balance"])
        avg = float(b["avg_buy_price"])
        pr = prices.get(ticker, 0)
        total_cost += avg * qty
        total_value += pr * qty

    return (total_value - total_cost) / total_cost * 100.0


# ===============================
# 9. ë©”ì¸ ì‹¤í–‰ ë£¨í”„
# ===============================
if __name__ == "__main__":
    print("ì „ëµ ì‹œì‘: 5ë¶„ë§ˆë‹¤ ì‹¤í–‰ / ì¼ë´‰+4ì‹œê°„ë´‰ ë™ì‹œ ì¡°ê±´ / í¬íŠ¸í´ë¦¬ì˜¤ -2% ì†ì ˆ")

    last_trade_keys = set()  # ì¤‘ë³µ ì£¼ë¬¸ ë°©ì§€
    universe = choose_universe()  # ë§¤ìˆ˜ í›„ë³´ ì¢…ëª© ì„ ì •

    while True:
        try:
            # 1) ì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ ì†ì ˆ ì²´í¬
            port_ret = get_portfolio_return_pct()
            if port_ret is not None and port_ret <= PORTFOLIO_CUT_PCT:
                print(f"[ì†ì ˆ] ì „ì²´ ìˆ˜ìµë¥  {port_ret:.2f}% â†’ ì „ëŸ‰ ë§¤ë„")
                sell_limit_all_holdings_at_market_price_snapshot()

            # 2) ê° ì¢…ëª©ë³„ ë§¤ìˆ˜/ë§¤ë„ ì‹ í˜¸ í™•ì¸
            cur_prices = pyupbit.get_current_price(universe)
            if isinstance(cur_prices, float):
                cur_prices = {universe[0]: cur_prices}

            buy_candidates = []
            # 3) ì¢…ëª©ë³„ë¡œ ì¼ë´‰/4ì‹œê°„ë´‰ ì‹œê·¸ë„ í™•ì¸
            for t in universe:
                cp = cur_prices.get(t, 0)
                if cp <= 0:
                    continue
                
                # ì¼ë´‰/4ì‹œê°„ë´‰ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                df_day = get_ohlcv(t, "day")
                time.sleep(SLEEP_API)
                df_4h = get_ohlcv(t, "minute240")
                time.sleep(SLEEP_API)
                
                # ë§¤ìˆ˜/ë§¤ë„ ì‹ í˜¸ íŒë‹¨
                sig_day = get_signal_for_timeframe(df_day, cp)
                sig_4h = get_signal_for_timeframe(df_4h, cp)

                # ë§¤ë„ ì¡°ê±´ ì¶©ì¡± ì‹œ ì „ëŸ‰ ë§¤ë„
                if sig_day["sell"] and sig_4h["sell"]:
                     # ê°™ì€ ìº”ë“¤ì—ì„œ ì¤‘ë³µ ë§¤ë„ ë°©ì§€
                    key_sell = (t, sig_day["bar_time"], sig_4h["bar_time"], "SELL")
                    if key_sell not in last_trade_keys:
                        sell_limit_all_coin(t, cp)
                        last_trade_keys.add(key_sell)

                # (B) ë§¤ìˆ˜ í›„ë³´: ë‘˜ ë‹¤ ë§¤ìˆ˜ ì‹ í˜¸ë©´ í›„ë³´ì— ì¶”ê°€
                if sig_day["buy"] and sig_4h["buy"]:
                    key_buy = (t, sig_day["bar_time"], sig_4h["bar_time"], "BUY")
                    # ê°™ì€ ìº”ë“¤ì—ì„œ ì¤‘ë³µ ë§¤ìˆ˜ ë°©ì§€ (í•œ ë²ˆë§Œ ì§„ì…)
                    if key_buy not in last_trade_keys:
                        buy_candidates.append((t, cp, key_buy))

            # 4) në“±ë¶„ ë§¤ìˆ˜ ë¡œì§
            #    - buy_candidates ì— ë‹´ê¸´ ì¢…ëª© ìˆ˜ = n
            #    - ë³´ìœ  ì›í™”ë¥¼ në“±ë¶„í•´ì„œ ê°ê° ë™ì¼ ê¸ˆì•¡ìœ¼ë¡œ ë§¤ìˆ˜
            #    - ë‹¨, ì—…ë¹„íŠ¸ ìµœì†Œì£¼ë¬¸ê¸ˆì•¡(5000ì›) ì œì•½ì´ ìˆìœ¼ë¯€ë¡œ, ê·¸ë³´ë‹¤ ì‘ì•„ì§€ë©´
            #      ì‹¤ì œ ë§¤ìˆ˜ ê°€ëŠ¥í•œ ì¢…ëª© ìˆ˜(m)ë¥¼ ì¤„ì—¬ì„œ ê¸ˆì•¡ì„ ì¬ë°°ë¶„í•©ë‹ˆë‹¤.
            if buy_candidates:
                # ìƒìœ„ 5ê°œê¹Œì§€ë§Œ ê³ ë ¤ (ìš”êµ¬ì‚¬í•­: ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ 5ìœ„ ì•ˆì—ì„œ nê°œ)
                buy_candidates = buy_candidates[:5]

                # í˜„ì¬ ë³´ìœ  ì›í™” ìŠ¤ëƒ…ìƒ· (ì´ ê°’ìœ¼ë¡œ ë“±ë¶„ ê¸ˆì•¡ì„ ê³„ì‚°)
                krw_snapshot = get_krw_balance()

                # ì‹¤ì œ ë§¤ìˆ˜ ê°€ëŠ¥í•œ ìµœëŒ€ ì¢…ëª© ìˆ˜(ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ì„ ë§Œì¡±í•˜ëŠ” ìˆ˜)ë¥¼ ê³„ì‚°
                # ì˜ˆ) 12,000ì›ì´ë©´ 2ì¢…ëª©ê¹Œì§€ë§Œ ê°€ëŠ¥(ê° 6,000ì›) â†’ 3ì¢…ëª©ìœ¼ë¡œ ë‚˜ëˆ„ë©´ 4,000ì›ì´ë¼ ìµœì†Œì£¼ë¬¸ ë¯¸ë‹¬
                max_affordable = int(krw_snapshot // MIN_ORDER_KRW)  # ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ ê¸°ì¤€ìœ¼ë¡œ ê°€ëŠ¥í•œ "ìµœëŒ€" ì¢…ëª© ìˆ˜
                n = len(buy_candidates)

                if max_affordable <= 0:
                    print(f"[ë§¤ìˆ˜ ê±´ë„ˆëœ€] ì›í™” ë¶€ì¡± (ë³´ìœ  {krw_snapshot:.0f}ì›, ìµœì†Œì£¼ë¬¸ {MIN_ORDER_KRW}ì›)")
                else:
                    # ì‹¤ì œë¡œ ë§¤ìˆ˜ì— ì‚¬ìš©í•  ì¢…ëª© ìˆ˜ m = min(n, max_affordable)
                    m = min(n, max_affordable)

                    # ë§¤ìˆ˜ ëŒ€ìƒìœ¼ë¡œ ìµœì¢… mê°œë§Œ ì‚¬ìš©
                    exec_list = buy_candidates[:m]

                    # më“±ë¶„ ê¸ˆì•¡(ê° ì¢…ëª© ë™ì¼ ê¸ˆì•¡)
                    per_ticket_krw = krw_snapshot / m

                    # per_ticket_krwê°€ í˜¹ì‹œë‚˜ ë°˜ì˜¬ë¦¼ ë“±ìœ¼ë¡œ ìµœì†Œì£¼ë¬¸ê¸ˆì•¡ë³´ë‹¤ ì•½ê°„ ì‘ì•„ì§ˆ ìˆ˜ ìˆì–´ ë§ˆì§€ë§‰ì— í•œ ë²ˆ ë” ì ê²€
                    if per_ticket_krw < MIN_ORDER_KRW:
                        # ì´ ê²½ìš°ëŠ” ê±°ì˜ ì—†ì§€ë§Œ, ì•ˆì „í•˜ê²Œ mì„ 1 ì¤„ì—¬ ë‹¤ì‹œ ê³„ì‚°
                        # (ì—¬ìœ ê°€ ì•ˆë˜ë©´ ì•„ì˜ˆ ë§¤ìˆ˜ ìŠ¤í‚µ)
                        m2 = int(krw_snapshot // MIN_ORDER_KRW)
                        if m2 <= 0:
                            print(f"[ë§¤ìˆ˜ ê±´ë„ˆëœ€] ì›í™” ë¶€ì¡± (ë³´ìœ  {krw_snapshot:.0f}ì›)")
                            exec_list = []
                        else:
                            exec_list = buy_candidates[:m2]
                            per_ticket_krw = krw_snapshot / m2

                    # ìµœì¢… ì‹¤í–‰
                    for (t, cp, key_buy) in exec_list:
                        buy_limit_by_krw(t, per_ticket_krw, cp)
                        last_trade_keys.add(key_buy)
                        time.sleep(SLEEP_API)

            # 5) ë£¨í”„ ëŒ€ê¸° (5ë¶„)
        except Exception as e:
            print("[ì˜¤ë¥˜]", e)

        time.sleep(CHECK_INTERVAL)
